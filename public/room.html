<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>협업 타이핑 룸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; overflow: hidden; }
        .turn-active { border: 2px solid #4ade80; box-shadow: 0 0 10px #4ade80; }
        .turn-inactive { border: 2px solid #f87171; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e2B; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .badge { display: inline-block; font-size: 0.75rem; padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-weight: 500; margin-left: 0.5rem; vertical-align: middle;}
        .badge-ko { background-color: #3b82f6; color: white; }
        .badge-trans { background-color: #10b981; color: white; }
        #userInfo svg { display: inline-block; vertical-align: middle; margin-right: 4px; width: 1em; height: 1em; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 flex flex-col h-screen p-4 gap-4">

    <header class="flex justify-between items-center bg-slate-800 p-3 rounded-lg shadow-lg">
        <h1 id="roomTitle" class="text-xl font-bold text-white">방 제목 불러오는 중...<span id="roomTypeBadge" class="badge"></span></h1>
        <div id="userInfo" class="flex items-center gap-5 text-sm text-slate-400">
            </div>
        <div class="flex items-center">
            <button id="openAutotextModal" class="hidden bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors mr-4">
                상용구 관리
            </button>
            <button id="presenter-mode-btn" class="hidden bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition-colors mr-4">
                프레젠터 뷰
            </button>
            <button id="exitButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                방 나가기
            </button>
        </div>
    </header>

    <main class="flex-grow flex gap-4 h-[calc(100vh-160px)]">
        <div id="typists-area" class="w-1/2 flex flex-col gap-4">
            <div id="my-player-container" class="bg-slate-800 p-4 rounded-lg flex-1 flex flex-col">
                <h2 id="my-player-nickname" class="text-lg font-bold mb-2 text-white">내 정보 / 입력자 1</h2>
                <textarea id="my-player-textarea" class="w-full h-full bg-slate-900 rounded-md p-3 text-lg focus:outline-none resize-none" disabled></textarea>
            </div>
            <div id="opponent-player-container" class="bg-slate-800 p-4 rounded-lg flex-1 flex flex-col">
                <h2 id="opponent-player-nickname" class="text-lg font-bold mb-2 text-white">상대방 / 입력자 2</h2>
                 <div id="opponent-player-waiting" class="w-full h-full flex items-center justify-center bg-slate-900 rounded-md">
                    <p class="text-slate-500">대기 중...</p>
                </div>
                <textarea id="opponent-player-textarea" class="w-full h-full bg-slate-900 rounded-md p-3 text-lg focus:outline-none resize-none hidden" disabled></textarea>
            </div>
        </div>

        <div id="completed-area" class="w-1/2 bg-slate-800 p-4 rounded-lg flex flex-col shadow-inner">
            <div class="flex justify-between items-center mb-2">
                <h2 class="text-lg font-bold text-white">완성된 문장</h2>
                <div class="flex items-center gap-4">
                    <div id="font-controls" class="flex items-center gap-2">
                        <button id="btn-font-decrease" class="bg-slate-600 hover:bg-slate-700 text-white font-bold w-7 h-7 rounded-full text-lg flex items-center justify-center leading-none">-</button>
                        <button id="btn-font-reset" class="bg-slate-600 hover:bg-slate-700 text-white font-bold py-1 px-3 rounded-md text-sm">초기화</button>
                        <button id="btn-font-increase" class="bg-slate-600 hover:bg-slate-700 text-white font-bold w-7 h-7 rounded-full text-lg flex items-center justify-center leading-none">+</button>
                    </div>
                    <div id="completed-controls" class="flex gap-2">
                        <button id="copy-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md text-sm transition-colors">내용 복사</button>
                        <button id="clear-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm transition-colors">내용 초기화</button>
                    </div>
                </div>
            </div>
            <div id="completed-text" class="w-full flex-grow bg-slate-900 rounded-md p-3 text-lg overflow-y-auto"></div>
        </div>
    </main>

    <footer class="bg-slate-800 p-3 rounded-lg text-sm text-center text-slate-400 shadow-lg"></footer>

    <div id="autotext-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div class="bg-slate-800 p-6 rounded-lg shadow-2xl max-w-lg w-full border border-sky-500">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-sky-400">상용구 관리</h2>
                <button id="autotext-modal-close" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="grid grid-cols-3 gap-4 mb-4">
                <input type="text" id="autotext-key" placeholder="단축어 (예: 마)" class="col-span-1 bg-slate-700 text-white px-3 py-2 rounded-md border border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500">
                <input type="text" id="autotext-value" placeholder="전체 텍스트 (예: 마이크로소프트)" class="col-span-2 bg-slate-700 text-white px-3 py-2 rounded-md border border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500">
            </div>
            <button id="add-autotext-btn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-md mb-4">추가</button>
            <h3 class="text-lg font-bold mb-2 text-slate-300">등록된 목록</h3>
            <div id="autotext-list" class="bg-slate-900 rounded-md p-3 h-48 overflow-y-auto"></div>
        </div>
    </div>

    <div id="shortcut-help-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div class="bg-slate-800 p-6 rounded-lg shadow-2xl max-w-lg w-full border border-green-500">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-green-400">단축키 도움말</h2>
                <button id="shortcut-help-modal-close" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-3 text-lg">
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">F1</span><span>이 도움말 창을 엽니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">Insert</span><span>입력을 마치고 상대방에게 주도권을 넘깁니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">F3</span><span>입력한 단축어를 등록된 상용구로 변환합니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">F4</span><span>자신이 입력하던 내용의 마지막 단어를 삭제합니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">F8</span><span>상대방이 입력하던 내용의 첫 단어를 삭제합니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">F10</span><span>'키:값' 형식으로 입력한 줄을 상용구로 등록합니다.</span></div>
                <div class="flex items-center"><span class="font-bold text-green-400 w-32">'단어'</span><span>(번역방) 단어를 로마자로 변환합니다. (예: '의성' -> uiseong)</span></div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        const params = new URLSearchParams(window.location.search);
        const roomId = params.get('id');
        const myNickname = params.get('nickname');
        const myRole = params.get('role');
        const password = params.get('password');
        let myId = null;
        let currentRoomState = {}; // 현재 방의 전체 상태를 저장
        let autotextMap = {};

        const roomTitleElem = document.getElementById('roomTitle');
        const userInfoElem = document.getElementById('userInfo');
        const completedTextElem = document.getElementById('completed-text');
        const footerElem = document.querySelector('footer');
        const openAutotextModalBtn = document.getElementById('openAutotextModal');
        
        const presenterModeBtn = document.getElementById('presenter-mode-btn');

        const roomTypeBadgeElem = document.getElementById('roomTypeBadge');

        const myUI = { container: document.getElementById('my-player-container'), nickname: document.getElementById('my-player-nickname'), textarea: document.getElementById('my-player-textarea') };
        const opponentUI = { container: document.getElementById('opponent-player-container'), nickname: document.getElementById('opponent-player-nickname'), textarea: document.getElementById('opponent-player-textarea'), waiting: document.getElementById('opponent-player-waiting') };
        const autotextModal = document.getElementById('autotext-modal');
        const autotextKeyInput = document.getElementById('autotext-key');
        const autotextValueInput = document.getElementById('autotext-value');
        const autotextListDiv = document.getElementById('autotext-list');
        const shortcutHelpModal = document.getElementById('shortcut-help-modal');
        
        const btnFontDecrease = document.getElementById('btn-font-decrease');
        const btnFontIncrease = document.getElementById('btn-font-increase');
        const btnFontReset = document.getElementById('btn-font-reset');

        function configureUIForRole() {
            if (myRole === 'observer') {
                document.getElementById('typists-area').classList.add('hidden');
                document.getElementById('completed-area').classList.remove('w-1/2');
                document.getElementById('completed-area').classList.add('w-full');
                footerElem.classList.add('hidden');
                document.getElementById('completed-controls').classList.add('hidden');
                
                presenterModeBtn.classList.remove('hidden');

            } else { // typist
                myUI.textarea.disabled = false;
                openAutotextModalBtn.classList.remove('hidden');
                footerElem.innerHTML = `
                    <span class="font-bold text-white mx-2">F1</span>: 도움말 |
                    <span class="font-bold text-white mx-2">INSERT</span>: 주도권 넘기기 | 
                    <span class="font-bold text-white mx-2">F3</span>: 상용구 변환 | 
                    <span class="font-bold text-white mx-2">(한 줄에) 키:값 + F10</span>: 상용구 등록 | 
                    <span class="font-bold text-white mx-2">F4</span>: 내 마지막 단어 삭제 | 
                    <span class="font-bold text-white mx-2">F8</span>: 상대 첫 단어 삭제
                `;
            }
        }

        const FONT_STEP = 0.1;
        const INITIAL_FONT_SIZE_REM = 1.125; 
        let currentFontSize = parseFloat(localStorage.getItem('room_fontSize')) || INITIAL_FONT_SIZE_REM;

        function applyFontSize() {
            completedTextElem.style.fontSize = `${currentFontSize}rem`;
            localStorage.setItem('room_fontSize', currentFontSize);
        }

        btnFontIncrease.addEventListener('click', () => {
            if (currentFontSize < 3) currentFontSize += FONT_STEP;
            applyFontSize();
        });
        btnFontDecrease.addEventListener('click', () => {
            if (currentFontSize > 0.5) currentFontSize -= FONT_STEP;
            applyFontSize();
        });
        btnFontReset.addEventListener('click', () => {
            currentFontSize = INITIAL_FONT_SIZE_REM;
            applyFontSize();
        });
        
        applyFontSize(); 

        // '완성된 문장' 렌더링 전용 함수
        function renderCompletedText(state) {
            if (!state) return;

            const { finalText, activeBuffer, lastProcessedBuffer, roomType } = state;
            const completed = (finalText || []).filter(line => line !== null && line !== undefined);
            let textParts = [...completed];
            let joiner;

            if (roomType === 'korean' && myRole === 'typist') {
                // [한글방 & 입력자]: 줄바꿈 없이 합침 + 활성 버퍼만 표시
                joiner = ''; 
                const activeTextToShow = (activeBuffer || '').trim(); // state의 activeBuffer 사용
                if (activeTextToShow) {
                    textParts.push(activeTextToShow);
                }
            } else {
                // [번역방] 또는 [관전자]: 줄바꿈으로 합침 + 활성 버퍼(번역 안된 부분)만 표시
                joiner = '\n'; 
                const activeTextToShow = (activeBuffer || '').substring((lastProcessedBuffer || '').length).trim();
                if (activeTextToShow) {
                    textParts.push(activeTextToShow);
                }
            }

            // 최종 렌더링
            const fullText = textParts.join(joiner);
            completedTextElem.innerHTML = fullText.replace(/\n/g, '<br>');

            // 자동 스크롤
            if (document.activeElement !== completedTextElem) {
                completedTextElem.scrollTop = completedTextElem.scrollHeight;
            }
        }

        // updateUI 함수 (렌더링 로직 분리)
        function updateUI(state) {
            currentRoomState = state; // 서버로부터 받은 최신 상태를 전역 변수에 저장
            if (!myId || !state) return;

            // 방 제목 및 방 종류 뱃지 업데이트
            if (state.roomName) roomTitleElem.childNodes[0].nodeValue = state.roomName + ' '; 
            if (state.roomType === 'korean') {
                roomTypeBadgeElem.textContent = '한글';
                roomTypeBadgeElem.className = 'badge badge-ko'; 
            } else if (state.roomType === 'translation') {
                roomTypeBadgeElem.textContent = '번역';
                roomTypeBadgeElem.className = 'badge badge-trans';
            } else {
                 roomTypeBadgeElem.textContent = ''; 
                 roomTypeBadgeElem.className = 'badge';
            }

            const allUsers = state.users || {};
            const typists = Object.entries(allUsers).filter(([, user]) => user.role === 'typist');
            
            // ▼▼▼ [수정됨] 'T' 오타 제거 ▼▼▼
            const observers = Object.entries(allUsers).filter(([, user]) => user.role === 'observer');
            // ▲▲▲ [수정 완료] ▲▲▲

            const isMyTurn = state.activeUserId === myId;
            const myTurnStatus = isMyTurn ? ' (내 차례)' : ' (대기중)';
            const myRoleText = (myRole === 'typist') ? `입력자${myTurnStatus}` : '관전자';
            
            userInfoElem.innerHTML = `
                <span class="flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10 8a3 3 0 100-6 3 3 0 000 6zM3.465 14.493a1.23 1.23 0 00.41 1.412A9.957 9.957 0 0010 18c2.31 0 4.438-.784 6.131-2.1.43-.333.604-.903.408-1.41a7.002 7.002 0 00-13.074.003z" /></svg>
                    ${myNickname}
                </span>
                <span class="flex items-center ${myRole === 'typist' ? 'text-yellow-300' : ''}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-5.5-2.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0zM10 12a5.99 5.99 0 00-4.793 2.39A6.483 6.483 0 0010 16.5a6.483 6.483 0 004.793-2.11A5.99 5.99 0 0010 12z" clip-rule="evenodd" /></svg>
                    ${myRoleText}
                </span>
                <span class="flex items-center">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10 9a3 3 0 100-6 3 3 0 000 6zM6 8a2 2 0 11-4 0 2 2 0 014 0zM1.49 15.326a.78.78 0 01-.358-.442 3 3 0 014.308-3.516 6.484 6.484 0 00-1.905 3.959c-.023.222-.014.442.025.654a4.97 4.97 0 01-2.07-.655zM16.44 15.98a4.97 4.97 0 002.07-.654.78.78 0 00.357-.442 3 3 0 00-4.308-3.517 6.484 6.484 0 011.907 3.96 2.32 2.32 0 01-.026.654zM18 9a3 3 0 100-6 3 3 0 000 6zM14 8a2 2 0 11-4 0 2 2 0 014 0zM10 18c-2.31 0-4.438-.78-6.131-2.1.43-.333.604-.903.408-1.41a7.002 7.002 0 0111.445 0 .78.78 0 01.408 1.41A9.955 9.955 0 0110 18z" /></svg>
                    입력자: ${typists.length}
                </span>
                <span class="flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 10a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5a.75.75 0 01.75-.75zM10 8a.75.75 0 01.75.75v.01a.75.75 0 01-1.5 0v-.01A.75.75 0 0110 8zm0-5a5.75 5.T5 0 100 11.5 5.75 5.75 0 000-11.5zM3 10a7 7 0 1114 0 7 7 0 01-14 0z" clip-rule="evenodd" /></svg> 
                    관전자: ${observers.length}
                </span>
            `;

            // --- 입력자 UI 업데이트 ---
            if (myRole === 'typist') {
                const me = allUsers[myId];
                const opponent = typists.find(([id]) => id !== myId);
                const opponentData = opponent ? opponent[1] : null;

                myUI.nickname.textContent = me ? me.nickname : '내 정보';

                if (opponentData) {
                    opponentUI.nickname.textContent = opponentData.nickname;
                    opponentUI.waiting.classList.add('hidden');
                    opponentUI.textarea.classList.remove('hidden');
                } else {
                    opponentUI.nickname.textContent = '상대방 (대기중)';
                    opponentUI.waiting.classList.remove('hidden');
                    opponentUI.textarea.classList.add('hidden');
                }

                const myBuffer = isMyTurn ? state.activeBuffer : state.inactiveBuffer;
                const opponentBuffer = isMyTurn ? state.inactiveBuffer : state.activeBuffer;

                const isMyTextareaActive = document.activeElement === myUI.textarea;

                if (myBuffer === "") {
                    myUI.textarea.value = "";
                }
                else if (!isMyTextareaActive) {
                    myUI.textarea.value = myBuffer || "";
                }

                if (opponentData) {
                    opponentUI.textarea.value = opponentBuffer || "";
                }

                myUI.container.classList.toggle('turn-active', isMyTurn);
                myUI.container.classList.toggle('turn-inactive', !isMyTurn);

                if (opponent) {
                    opponentUI.container.classList.toggle('turn-active', !isMyTurn);
                    opponentUI.container.classList.toggle('turn-inactive', isMyTurn);
                } else {
                    opponentUI.container.classList.remove('turn-active', 'turn-inactive');
                }
            }

            // '완성된 문장'은 'renderCompletedText' 함수를 호출하여 렌더링
            renderCompletedText(state);
        }


        function saveAutotext() { localStorage.setItem('collab_autotext', JSON.stringify(autotextMap)); }
        function loadAutotext() { const saved = localStorage.getItem('collab_autotext'); if (saved) autotextMap = JSON.parse(saved); renderAutotextList(); }
        function renderAutotextList() {
            autotextListDiv.innerHTML = '';
            if (Object.keys(autotextMap).length === 0) {
                autotextListDiv.innerHTML = '<p class="text-slate-500 text-center">등록된 상용구가 없습니다.</p>';
                return;
            }
            for (const key in autotextMap) {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center p-2 rounded hover:bg-slate-700';
                item.innerHTML = `<div><span class="font-bold text-sky-400">${key}</span><span class="text-slate-400 mx-2">→</span><span>${autotextMap[key]}</span></div><button data-key="${key}" class="delete-autotext-btn bg-red-800 text-white text-xs font-bold py-1 px-2 rounded">삭제</button>`;
                autotextListDiv.appendChild(item);
            }
        }

        configureUIForRole();
        loadAutotext();

        socket.on('connect', () => { myId = socket.id; socket.emit('enterRoom', { roomId, nickname: myNickname, role: myRole, password }); });
        socket.on('disconnect', () => { alert('서버와의 연결이 끊겼습니다. 로비로 이동합니다.'); window.location.href = '/'; });
        socket.on('roomError', ({ message }) => { alert(message); window.location.href = '/'; });
        
        socket.on('roomDeleted', ({ message }) => {
            alert(message);
            window.location.href = '/';
        });

        document.getElementById('exitButton').addEventListener('click', () => { window.location.href = '/'; });
        
        // 프레젠테이션 모드 버튼 리스너 (팝업 기능 수정)
        presenterModeBtn.addEventListener('click', () => {
            // '_blank' 대신 윈도우 이름과 피처를 지정하여 팝업으로 띄움
            window.open(
                `presenter_view.html?id=${roomId}`, 
                'Presenter_View', 
                'width=1280,height=720,resizable=yes,scrollbars=yes'
            );
        });

        socket.on('updateRoomState', (roomState) => { updateUI(roomState); });

        socket.on('forceUpdateBuffer', ({ text }) => {
            myUI.textarea.value = text;
            socket.emit('updateText', { roomId, text: text, timestamp: Date.now() }); 
        });

        if (myRole === 'typist') {

            // '낙관적 렌더링' 및 '서버 전송'을 수행하는 공통 함수
            const handleTextInput = (e) => {
                const newText = e.target.value;
                const timestamp = Date.now();

                // '낙관적 UI' 조건: '한글' 방, '입력자', '내 턴'
                const isMyTurn = currentRoomState.activeUserId === myId;
                if (currentRoomState.roomType === 'korean' && myRole === 'typist' && isMyTurn) {
                    const optimisticState = { 
                        ...currentRoomState, 
                        activeBuffer: newText 
                    };
                    renderCompletedText(optimisticState);
                }

                // [서버 동기화]
                socket.emit('updateText', { 
                    roomId, 
                    text: newText, 
                    timestamp: timestamp 
                });
            };

            // input 이벤트 리스너
            myUI.textarea.addEventListener('input', handleTextInput);

            // compositionend 이벤트 리스너
            myUI.textarea.addEventListener('compositionend', handleTextInput);


            window.addEventListener('keydown', (e) => {
                if (e.key === 'F1') {
                    e.preventDefault();
                    shortcutHelpModal.classList.remove('hidden');
                }

                if (document.activeElement !== myUI.textarea) return;

                const textarea = myUI.textarea;
                const isMyTurn = currentRoomState.activeUserId === myId;

                switch (e.key) {
                    case 'Insert':
                        e.preventDefault();
                        if (isMyTurn) socket.emit('passTurn', { roomId });
                        break;

                    case 'F3':
                        e.preventDefault();
                        const textF3 = textarea.value; const cursorPosF3 = textarea.selectionStart;
                        const textBeforeCursor = textF3.substring(0, cursorPosF3);
                        const lastSeparatorIndex = Math.max(textBeforeCursor.lastIndexOf(' '), textBeforeCursor.lastIndexOf('\n'));
                        const key = textBeforeCursor.substring(lastSeparatorIndex + 1);
                        const expansion = autotextMap[key];
                        if (expansion) {
                            const newText = textF3.substring(0, lastSeparatorIndex + 1) + expansion + textF3.substring(cursorPosF3);
                            textarea.value = newText;
                            const newCursorPos = lastSeparatorIndex + 1 + expansion.length;
                            textarea.setSelectionRange(newCursorPos, newCursorPos);
                            socket.emit('updateText', { roomId, text: newText, timestamp: Date.now() });
                        }
                        break;

                    case 'F4':
                        e.preventDefault();
                        const bufferValue = textarea.value;
                        const trimmedText = bufferValue.trimEnd();
                        const lastSep = Math.max(trimmedText.lastIndexOf(' '), trimmedText.lastIndexOf('\n'));
                        const newTextF4 = (lastSep !== -1) ? trimmedText.substring(0, lastSep) : "";
                        textarea.value = newTextF4;
                        socket.emit('updateText', { roomId, text: newTextF4, timestamp: Date.now() });
                        break;

                    case 'F8':
                        e.preventDefault();
                        if(isMyTurn) socket.emit('deleteOpponentFirstWord', { roomId });
                        break;

                    case 'F10':
                        e.preventDefault();
                        const textF10 = textarea.value; const cursorPosF10 = textarea.selectionStart;
                        const lineStartIndex = textF10.lastIndexOf('\n', cursorPosF10 - 1) + 1;
                        const line = textF10.substring(lineStartIndex, textF10.indexOf('\n', lineStartIndex) === -1 ? textF10.length : textF10.indexOf('\n', lineStartIndex));
                        const colonIndex = line.indexOf(':');
                        if (colonIndex > 0) {
                            const rawKeyPart = line.substring(0, colonIndex).trim();
                            const keyF10 = rawKeyPart.substring(rawKeyPart.lastIndexOf(' ') + 1);
                            const valueF10 = line.substring(colonIndex + 1).trimStart();
                            if (keyF10 && valueF10) {
                                autotextMap[keyF10] = valueF10;
                                saveAutotext(); renderAutotextList();
                                const partToKeep = rawKeyPart.lastIndexOf(' ') === -1 ? '' : rawKeyPart.substring(0, rawKeyPart.lastIndexOf(' ') + 1);
                                const newText = textF10.substring(0, lineStartIndex) + partToKeep + textF10.substring(lineStartIndex + line.length +1);
                                textarea.value = newText;
                                const newCursorPos = lineStartIndex + partToKeep.length;
                                textarea.setSelectionRange(newCursorPos, newCursorPos);
                                socket.emit('updateText', { roomId, text: newText, timestamp: Date.now() });
                            }
                        }
                        break;
                }
            });

            openAutotextModalBtn.addEventListener('click', () => autotextModal.classList.remove('hidden'));
            document.getElementById('autotext-modal-close').addEventListener('click', () => autotextModal.classList.add('hidden'));
            document.getElementById('shortcut-help-modal-close').addEventListener('click', () => shortcutHelpModal.classList.add('hidden'));
            document.getElementById('add-autotext-btn').addEventListener('click', () => {
                const key = autotextKeyInput.value.trim(); const value = autotextValueInput.value.trim();
                if (key.includes(' ')) { alert("상용구 단축어에는 띄어쓰기를 포함할 수 없습니다."); return; }
                if (key && value) { autotextMap[key] = value; saveAutotext(); renderAutotextList(); autotextKeyInput.value = ''; autotextValueInput.value = ''; autotextKeyInput.focus(); }
            });
            autotextListDiv.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-autotext-btn')) {
                    const key = e.target.getAttribute('data-key');
                    if (confirm(`'${key}' 상용구를 삭제하시겠습니까?`)) { delete autotextMap[key]; saveAutotext(); renderAutotextList(); }
                }
            });

            document.getElementById('copy-btn').addEventListener('click', () => {
                const textToCopy = completedTextElem.innerHTML.replace(/<br\s*[\/]?>/gi, '\n');
                navigator.clipboard.writeText(textToCopy).then(() => {
                    alert('내용이 클립보드에 복사되었습니다.');
                }).catch(err => {
                    console.error('클립보드 복사 실패: ', err);
                    alert('클립보드 복사에 실패했습니다.');
                });
            });

            document.getElementById('clear-btn').addEventListener('click', () => {
                if (confirm('정말로 모든 내용을 초기화하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                    socket.emit('clearText', { roomId });
                }
            });
        }
    </script>
</body>
</html>