<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프레젠테이션 뷰</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0f172a;
        }
        #presentation-text {
            font-family: 'Noto Sans KR', sans-serif;
            color: #e2e8f0;
            width: 100%;
            height: 100%;
            padding: 2rem;
            box-sizing: border-box;
            font-size: 2.25rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            transition: font-size 0.2s, padding-bottom 0.2s;
        }
        #presentation-text::-webkit-scrollbar {
            display: none;
        }
        #menu-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(5px);
            padding: 12px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 100;
        }
        #menu-bar.visible {
            transform: translateY(0);
        }
        #bottom-trigger {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            z-index: 99;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 14px;
            color: #cbd5e1;
            font-weight: 500;
        }
        .control-group button {
            background-color: #334155;
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .control-group button:hover {
            background-color: #475569;
        }
        .control-group .reset-btn {
            width: auto;
            border-radius: 16px;
            padding: 0 12px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="presentation-text">불러오는 중...</div>

    <div id="bottom-trigger"></div>

    <div id="menu-bar">
        <div class="control-group">
            <label>텍스트 크기</label>
            <button id="btn-font-decrease">-</button>
            <button id="btn-font-reset" class="reset-btn">초기화</button>
            <button id="btn-font-increase">+</button>
        </div>
        <div class="control-group">
            <label>하단 여백</label>
            <button id="btn-padding-decrease">-</button>
            <button id="btn-padding-reset" class="reset-btn">초기화</button>
            <button id="btn-padding-increase">+</button>
        </div>
    </div>


    <script src="/socket.io/socket.io.js"></script>

    <script>
        const presentationTextElem = document.getElementById('presentation-text');
        const btnFontDecrease = document.getElementById('btn-font-decrease');
        const btnFontIncrease = document.getElementById('btn-font-increase');
        const btnFontReset = document.getElementById('btn-font-reset');
        const btnPaddingDecrease = document.getElementById('btn-padding-decrease');
        const btnPaddingIncrease = document.getElementById('btn-padding-increase');
        const btnPaddingReset = document.getElementById('btn-padding-reset');

        const menuBar = document.getElementById('menu-bar');
        const bottomTrigger = document.getElementById('bottom-trigger');
        let menuHideTimer = null;

        function showMenu() {
            clearTimeout(menuHideTimer);
            menuBar.classList.add('visible');
        }

        function hideMenu() {
            menuHideTimer = setTimeout(() => {
                menuBar.classList.remove('visible');
            }, 300);
        }

        bottomTrigger.addEventListener('mouseenter', showMenu);
        bottomTrigger.addEventListener('mouseleave', hideMenu);
        menuBar.addEventListener('mouseenter', showMenu);
        menuBar.addEventListener('mouseleave', hideMenu);

        const FONT_STEP = 0.1;
        const PADDING_STEP = 2;
        const INITIAL_FONT_SIZE = 2.25;
        const INITIAL_PADDING_BOTTOM = 2;

        let currentFontSize = parseFloat(localStorage.getItem('presenter_fontSize')) || INITIAL_FONT_SIZE;
        let currentPaddingBottom = parseFloat(localStorage.getItem('presenter_paddingBottom')) || INITIAL_PADDING_BOTTOM;

        function applyStyles() {
            presentationTextElem.style.fontSize = `${currentFontSize}rem`;
            presentationTextElem.style.paddingBottom = `${currentPaddingBottom}rem`;
            localStorage.setItem('presenter_fontSize', currentFontSize);
            localStorage.setItem('presenter_paddingBottom', currentPaddingBottom);
            presentationTextElem.scrollTop = presentationTextElem.scrollHeight;
        }

        btnFontIncrease.addEventListener('click', () => {
            if (currentFontSize < 5) currentFontSize += FONT_STEP;
            applyStyles();
        });
        btnFontDecrease.addEventListener('click', () => {
            if (currentFontSize > 1) currentFontSize -= FONT_STEP;
            applyStyles();
        });
        btnFontReset.addEventListener('click', () => {
            currentFontSize = INITIAL_FONT_SIZE;
            applyStyles();
        });

        btnPaddingIncrease.addEventListener('click', () => {
            currentPaddingBottom += PADDING_STEP;
            applyStyles();
        });
        btnPaddingDecrease.addEventListener('click', () => {
            if (currentPaddingBottom > 0) currentPaddingBottom -= PADDING_STEP;
            applyStyles();
        });
        btnPaddingReset.addEventListener('click', () => {
            currentPaddingBottom = INITIAL_PADDING_BOTTOM;
            applyStyles();
        });

        applyStyles();

        // --- Socket.io 로직 시작 ---
        const socket = io();
        const params = new URLSearchParams(window.location.search);
        const roomId = params.get('id');

        if (!roomId) {
            presentationTextElem.textContent = '오류: 방 ID를 찾을 수 없습니다.';
        }

        socket.on('connect', () => {
            if (roomId) {
                socket.emit('enterRoom', {
                    roomId,
                    nickname: 'Presenter',
                    role: 'observer',
                    password: ''
                });
                presentationTextElem.textContent = '방에 연결하는 중...';
            }
        });

        socket.on('disconnect', () => {
            presentationTextElem.textContent = '서버와 연결이 끊겼습니다.';
        });

        socket.on('roomError', ({ message }) => {
            presentationTextElem.textContent = `오류: ${message}`;
        });

        // ▼▼▼ [추가됨] 방 삭제 알림 수신 리스너 ▼▼▼
        socket.on('roomDeleted', ({ message }) => {
            alert(message);
            // 프레젠터 뷰는 로비로 이동하는 대신 창을 닫도록 처리
            window.close();
        });
        // ▲▲▲ [추가 완료] ▲▲▲

        // ▼▼▼ [수정됨] 텍스트 렌더링 로직 수정 (inactiveBuffer 제외) ▼▼▼
        socket.on('updateRoomState', (state) => {
            if (!state) {
                presentationTextElem.textContent = '방 정보를 불러오는 데 실패했습니다.';
                return;
            }

            const { finalText, activeBuffer, lastProcessedBuffer } = state;

            const completed = (finalText || []).filter(line => line !== null && line !== undefined);
            let textParts = [...completed];
            let joiner = '\n'; // 프레젠터 뷰는 항상 '줄바꿈'으로 연결

            // '활성 버퍼'에서는 '아직 처리 안된 새 텍스트'만 가져옴
            const newTextInActiveBuffer = activeBuffer.substring(lastProcessedBuffer.length).trim();

            if (newTextInActiveBuffer) {
                textParts.push(newTextInActiveBuffer);
            }
            // inactiveBuffer(비활성 입력자)는 여기서 제외

            // 최종 렌더링
            const fullText = textParts.join(joiner);
            presentationTextElem.innerHTML = fullText.replace(/\n/g, '<br>');

            // 자동 스크롤
            presentationTextElem.scrollTop = presentationTextElem.scrollHeight;
        });
        // ▲▲▲ [수정 완료] ▲▲▲

    </script>
</body>
</html>